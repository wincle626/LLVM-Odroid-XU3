/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void BPFInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const uint32_t OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    448U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    441U,	// BUNDLE
    458U,	// LIFETIME_START
    428U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    646U,	// ADD_ri
    588U,	// ADD_rr
    2935U,	// ADJCALLSTACKDOWN
    5019U,	// ADJCALLSTACKUP
    652U,	// AND_ri
    598U,	// AND_rr
    2602U,	// BSWAP16
    2569U,	// BSWAP32
    2593U,	// BSWAP64
    720U,	// DIV_ri
    789U,	// DIV_rr
    16947U,	// FI_ri
    2774U,	// JAL
    98999U,	// JEQ_ri
    99072U,	// JEQ_rr
    2806U,	// JMP
    98975U,	// JNE_ri
    98923U,	// JNE_rr
    98968U,	// JSGE_ri
    98917U,	// JSGE_rr
    99017U,	// JSGT_ri
    99087U,	// JSGT_rr
    98962U,	// JUGE_ri
    98912U,	// JUGE_rr
    99011U,	// JUGT_ri
    99082U,	// JUGT_rr
    16957U,	// LDB
    16977U,	// LDD
    17008U,	// LDH
    17183U,	// LDW
    6966U,	// LD_ABS_B
    6992U,	// LD_ABS_H
    7018U,	// LD_ABS_W
    6953U,	// LD_IND_B
    6979U,	// LD_IND_H
    7005U,	// LD_IND_W
    49682U,	// LD_imm64
    164587U,	// LD_pseudo
    33562U,	// MOV_ri
    33562U,	// MOV_rr
    689U,	// MUL_ri
    742U,	// MUL_rr
    2811U,	// NOP
    702U,	// OR_ri
    774U,	// OR_rr
    473U,	// RET
    677U,	// SLL_ri
    732U,	// SLL_rr
    634U,	// SRA_ri
    568U,	// SRA_rr
    683U,	// SRL_ri
    737U,	// SRL_rr
    1090U,	// STB
    1115U,	// STD
    1141U,	// STH
    1316U,	// STW
    640U,	// SUB_ri
    583U,	// SUB_rr
    9098U,	// Select
    410113U,	// XADD32
    410137U,	// XADD64
    701U,	// XOR_ri
    773U,	// XOR_rr
    0U
  };

  static const char AsmStrs[] = {
  /* 0 */ 'x', 'a', 'd', 'd', '3', '2', 9, 0,
  /* 8 */ 'b', 's', 'w', 'a', 'p', '3', '2', 9, 0,
  /* 17 */ 'l', 'd', '_', '6', '4', 9, 0,
  /* 24 */ 'x', 'a', 'd', 'd', '6', '4', 9, 0,
  /* 32 */ 'b', 's', 'w', 'a', 'p', '6', '4', 9, 0,
  /* 41 */ 'b', 's', 'w', 'a', 'p', '1', '6', 9, 0,
  /* 50 */ 'l', 'e', 'a', 9, 0,
  /* 55 */ 's', 'r', 'a', 9, 0,
  /* 60 */ 'l', 'd', 'b', 9, 0,
  /* 65 */ 's', 't', 'b', 9, 0,
  /* 70 */ 's', 'u', 'b', 9, 0,
  /* 75 */ 'a', 'd', 'd', 9, 0,
  /* 80 */ 'l', 'd', 'd', 9, 0,
  /* 85 */ 'a', 'n', 'd', 9, 0,
  /* 90 */ 's', 't', 'd', 9, 0,
  /* 95 */ 'j', 'g', 'e', 9, 0,
  /* 100 */ 'j', 's', 'g', 'e', 9, 0,
  /* 106 */ 'j', 'n', 'e', 9, 0,
  /* 111 */ 'l', 'd', 'h', 9, 0,
  /* 116 */ 's', 't', 'h', 9, 0,
  /* 121 */ 's', 'r', 'a', 'i', 9, 0,
  /* 127 */ 's', 'u', 'b', 'i', 9, 0,
  /* 133 */ 'a', 'd', 'd', 'i', 9, 0,
  /* 139 */ 'a', 'n', 'd', 'i', 9, 0,
  /* 145 */ 'j', 'g', 'e', 'i', 9, 0,
  /* 151 */ 'j', 's', 'g', 'e', 'i', 9, 0,
  /* 158 */ 'j', 'n', 'e', 'i', 9, 0,
  /* 164 */ 's', 'l', 'l', 'i', 9, 0,
  /* 170 */ 's', 'r', 'l', 'i', 9, 0,
  /* 176 */ 'm', 'u', 'l', 'i', 9, 0,
  /* 182 */ 'j', 'e', 'q', 'i', 9, 0,
  /* 188 */ 'x', 'o', 'r', 'i', 9, 0,
  /* 194 */ 'j', 'g', 't', 'i', 9, 0,
  /* 200 */ 'j', 's', 'g', 't', 'i', 9, 0,
  /* 207 */ 'd', 'i', 'v', 'i', 9, 0,
  /* 213 */ 'c', 'a', 'l', 'l', 9, 0,
  /* 219 */ 's', 'l', 'l', 9, 0,
  /* 224 */ 's', 'r', 'l', 9, 0,
  /* 229 */ 'm', 'u', 'l', 9, 0,
  /* 234 */ 'l', 'd', '_', 'p', 's', 'e', 'u', 'd', 'o', 9, 0,
  /* 245 */ 'j', 'm', 'p', 9, 0,
  /* 250 */ 'n', 'o', 'p', 9, 0,
  /* 255 */ 'j', 'e', 'q', 9, 0,
  /* 260 */ 'x', 'o', 'r', 9, 0,
  /* 265 */ 'j', 'g', 't', 9, 0,
  /* 270 */ 'j', 's', 'g', 't', 9, 0,
  /* 276 */ 'd', 'i', 'v', 9, 0,
  /* 281 */ 'm', 'o', 'v', 9, 0,
  /* 286 */ 'l', 'd', 'w', 9, 0,
  /* 291 */ 's', 't', 'w', 9, 0,
  /* 296 */ 'l', 'd', 'i', 'n', 'd', '_', 'b', 9, 'r', '0', ',', 32, 0,
  /* 309 */ 'l', 'd', 'a', 'b', 's', '_', 'b', 9, 'r', '0', ',', 32, 0,
  /* 322 */ 'l', 'd', 'i', 'n', 'd', '_', 'h', 9, 'r', '0', ',', 32, 0,
  /* 335 */ 'l', 'd', 'a', 'b', 's', '_', 'h', 9, 'r', '0', ',', 32, 0,
  /* 348 */ 'l', 'd', 'i', 'n', 'd', '_', 'w', 9, 'r', '0', ',', 32, 0,
  /* 361 */ 'l', 'd', 'a', 'b', 's', '_', 'w', 9, 'r', '0', ',', 32, 0,
  /* 374 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 393 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', 32, 'P', 'S', 'E', 'U', 'D', 'O', 32, 0,
  /* 410 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 427 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 440 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 447 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 457 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 472 */ 'r', 'e', 't', 0,
  };

  O << "\t";

  // Emit the opcode for the instruction.
  uint32_t Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 511)-1;


  // Fragment 0 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 9) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, RET
    return;
    break;
  case 1:
    // ADD_ri, ADD_rr, ADJCALLSTACKDOWN, ADJCALLSTACKUP, AND_ri, AND_rr, BSWA...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // STB, STD, STH, STW
    printMemOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 11) & 7) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_ri, ADD_rr, AND_ri, AND_rr, DIV_ri, DIV_rr, FI_ri, JEQ_ri, JEQ_rr,...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN, BSWAP16, BSWAP32, BSWAP64, JAL, JMP, NOP
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << ' '; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 3:
    // LD_ABS_B, LD_ABS_H, LD_ABS_W, LD_IND_B, LD_IND_H, LD_IND_W
    O << ".data + "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 4:
    // Select
    O << " = "; 
    printOperand(MI, 1, O); 
    O << ' '; 
    printOperand(MI, 3, O); 
    O << ' '; 
    printOperand(MI, 2, O); 
    O << " ? "; 
    printOperand(MI, 4, O); 
    O << " : "; 
    printOperand(MI, 5, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 14) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_ri, ADD_rr, AND_ri, AND_rr, DIV_ri, DIV_rr, MUL_ri, MUL_rr, OR_ri,...
    printOperand(MI, 2, O); 
    return;
    break;
  case 1:
    // FI_ri, LDB, LDD, LDH, LDW, XADD32, XADD64
    printMemOperand(MI, 1, O); 
    break;
  case 2:
    // JEQ_ri, JEQ_rr, JNE_ri, JNE_rr, JSGE_ri, JSGE_rr, JSGT_ri, JSGT_rr, JU...
    printOperand(MI, 1, O); 
    break;
  case 3:
    // LD_imm64
    printImm64Operand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 16) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // FI_ri, LDB, LDD, LDH, LDW, MOV_ri, MOV_rr
    return;
    break;
  case 1:
    // JEQ_ri, JEQ_rr, JNE_ri, JNE_rr, JSGE_ri, JSGE_rr, JSGT_ri, JSGT_rr, JU...
    O << " goto "; 
    printOperand(MI, 2, O); 
    return;
    break;
  case 2:
    // LD_pseudo, XADD32, XADD64
    O << ", "; 
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 18) & 1) {
    // XADD32, XADD64
    printOperand(MI, 3, O); 
    return;
  } else {
    // LD_pseudo
    printImm64Operand(MI, 2, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *BPFInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 13 && "Invalid register number!");

  static const char AsmStrs[] = {
  /* 0 */ 'r', '1', '0', 0,
  /* 4 */ 'r', '0', 0,
  /* 7 */ 'r', '1', '1', 0,
  /* 11 */ 'r', '1', 0,
  /* 14 */ 'r', '2', 0,
  /* 17 */ 'r', '3', 0,
  /* 20 */ 'r', '4', 0,
  /* 23 */ 'r', '5', 0,
  /* 26 */ 'r', '6', 0,
  /* 29 */ 'r', '7', 0,
  /* 32 */ 'r', '8', 0,
  /* 35 */ 'r', '9', 0,
  };

  static const uint8_t RegAsmOffset[] = {
    4, 11, 14, 17, 20, 23, 26, 29, 32, 35, 0, 7, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool BPFInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
